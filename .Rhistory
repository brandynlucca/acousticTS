tmp.df <- data.frame(An=dev_all$An[i], f=dev_all$f[i], Dev=median(minvals[minval.idx]), Year=2017, phase=subdb$phase[1])
dev.min <- rbind(dev.min, tmp.df)
# print(tmp.df)
}
}
}
dev.min$f <- as.factor(dev.min$f)
dev.min <- dev.min[dev.min$Dev > -20 & dev.min$Dev < 20,]
devmeans <- aggregate(Dev~f, dev.min, mean)
devmeds <- aggregate(Dev~f, dev.min, median)
lower_ci <- function(mean, se, n, conf_level = 0.95){
lower_ci <- mean - qt(1 - ((1 - conf_level) / 2), n - 1) * se
}
upper_ci <- function(mean, se, n, conf_level = 0.95){
upper_ci <- mean + qt(1 - ((1 - conf_level) / 2), n - 1) * se
}
dev.min %>%
group_by(f) %>%
summarise(smean = mean(Dev, na.rm=T),
ssd = sd(Dev, na.rm=T),
count = n()) %>%
mutate(se = ssd / sqrt(count),
lower_ci = lower_ci(smean, se, count),
upper_ci = upper_ci(smean, se, count))
require(ggjoy)
require(ggplot2)
# dev.min$f <- as.numeric(as.character(dev.min$f))
ggplot(data=dev.min, aes(x=Dev,y=f)) +
geom_vline(aes(xintercept=0), size=2, color="gray40", linetype=2) +
geom_joy(scale=1, jittered_points=T, jittered_points = TRUE,
position = position_points_jitter(width = 0.05, height = 0),
point_shape = '|', point_size = 3, point_alpha = 1, alpha = 0.7, point_color="black") +
geom_point(data=devmeans, aes(y=as.numeric(as.factor(f))+0.5, x=Dev), size=4, shape=19) +
geom_point(data=devmeds, aes(y=as.numeric(as.factor(f))+0.5, x=Dev), size=4, shape=4) +
coord_cartesian(xlim=c(-12.5,12.5)) +
# coord_flip() +
scale_x_continuous(expand=c(0,0)) +
theme_bw() +
theme(text=element_text(size=18), axis.text=element_text(size=16, color="black"),
panel.grid=element_blank()) +
labs(x=expression(paste("Model difference (",Delta,"dB re: 1",m^2,")")),
y="Frequency (kHz)")
require(dplyr)
ggplot(data=dev.min, aes(x=f,y=Dev)) +
geom_hline(aes(yintercept=0), linetype=1, colour="gray10", size=1) +
geom_violin(scale="width") +
geom_jitter(alpha=0.75, color="gray80") +
# facet_wrap(~as.factor(Phase)) +
geom_point(data=devmeans, aes(x=as.factor(f), y=Dev), size=5, shape=19) +
geom_point(data=devmeds, aes(x=as.factor(f), y=Dev), size=5, shape=4) +
theme_bw() +
theme(text=element_text(size=18), axis.text=element_text(size=16, colour="black"),
panel.grid=element_blank(), strip.background=element_blank(), strip.text=element_blank()) +
labs(y=expression(paste("Model difference (",Delta,"dB re: 1",m^2,")")),
x="Frequency (kHz)") +
scale_y_continuous(limits=c(-20,20)) +
geom_text(aes(x=5, y=20, label="n = 115"), size=6.5)
dev.min16 <- data.frame(An=c(), f=c(), Dev=c(), Year=c(), phase=c())
dev_all16 <- data.frame(An=as.integer(as.character(df16$An)), f=df16$f, TSE=df16$TS)
dev_all16 <- dev_all16[dev_all16$TSE != 0.0,]
dbagg16 <- devdf16
dbagg16 <- dbagg16[dbagg16$phase == 0.2,]
for(i in 1:nrow(dev_all16)){
id <- dev_all16$An[i]
idx <- which(id == dbagg16$Animal)
fidx <- which(dbagg16$frequency[idx] == dev_all16$f[i]*1e3)
if(length(fidx) > 0){
# print(paste(i, "TRUE"))
minvals <- dev_all16$TS[i] - dbagg16$TS[idx[fidx]]
minval.idx <- which(abs(minvals) == min(abs(minvals)))
# tmp.df <- data.frame(An=dev_all$An[i], f=dev_all$f[i], Dev=minvals[minval.idx], Phase=dbagg$Phase[idx[fidx]])
tmp.df <- data.frame(An=dev_all16$An[i], f=dev_all16$f[i], Dev=minvals[minval.idx], Year=2016, phase=dbagg16$phase[idx][1])
dev.min16 <- rbind(dev.min16, tmp.df)
}
}
# dev.min$Dev[dev.min$f == 120] <- dev.min$Dev[dev.min$f == 120] + 0.5
# dev.min$Dev[dev.min$f == 75] <- dev.min$Dev[dev.min$f == 75] - 11.7
# dev.min$Dev[dev.min$f == 200] <- dev.min$Dev[dev.min$f == 200] + 2.6
# dev.min$Dev[dev.min$f == 192] <- dev.min$Dev[dev.min$f == 192] + 0.4
# dev.min$Dev[dev.min$f == 150] <- dev.min$Dev[dev.min$f == 150] + 0.2
# dev.min$Dev[dev.min$f == 55] <- dev.min$Dev[dev.min$f == 55] - 7.4
dev.min16$f <- as.factor(dev.min16$f)
dev.min %>%
group_by(f) %>%
summarise(smean = mean(Dev, na.rm=T),
ssd = sd(Dev, na.rm=T),
count = n(),
smax = max(Dev),
smin = min(Dev)) %>%
mutate(se = ssd / sqrt(count),
lower_ci = lower_ci(smean, se, count),
upper_ci = upper_ci(smean, se, count))
dev.min16 %>%
group_by(f) %>%
summarise(smean = mean(Dev, na.rm=T),
ssd = sd(Dev, na.rm=T),
count = n(),
smax = max(Dev),
smin = min(Dev)) %>%
mutate(se = ssd / sqrt(count),
lower_ci = lower_ci(smean, se, count),
upper_ci = upper_ci(smean, se, count))
dev.min_all <- rbind(dev.min[dev.min$phase == 0.2,], dev.min16)
gen_sum <- dev.min_all %>%
group_by(f) %>%
summarise(smean = mean(Dev, na.rm=T),
ssd = sd(Dev, na.rm=T),
count = n(),
smax = max(Dev),
smin = min(Dev),
smed = median(Dev)) %>%
mutate(se = ssd / sqrt(count),
lower_ci = lower_ci(smean, se, count),
upper_ci = upper_ci(smean, se, count))
gen_sum
gen_sum
dev.min_all %>%
group_by(f) %>%
summarise(smean = mean(Dev, na.rm=T),
ssd = sd(Dev, na.rm=T),
count = n(),
smax = max(Dev),
smin = min(Dev),
smed = median(Dev)) %>%
mutate(se = ssd / sqrt(count),
lower_ci = lower_ci(smean, se, count),
upper_ci = upper_ci(smean, se, count))
dev.min_all %>%
group_by(f) %>%
summarise(smean = mean(Dev, na.rm=T),
ssd = sd(Dev, na.rm=T),
count = n(),
smax = max(Dev),
smin = min(Dev),
smed = median(Dev)) %>%
mutate(se = ssd / sqrt(count),
lower_ci = lower_ci(smean, se, count),
upper_ci = upper_ci(smean, se, count))
View(gen_sum)
gen_sum[10:21,]
gen_sum[10:21,]
install.packages("flexdashboard")
?SDWBA
require(acousticTS)
?SDWBA
?data
?FFSgenerate
?degrad
?Shapely
?SDWBA
?SDWBA.sim
install_github("brandynlucca/acousticTS@test-branch")
devtools::install_github("brandynlucca/acousticTS@test-branch")
devtools::install_github("brandynlucca/acousticTS@test-branch")
require(acousticTS)
#Create vectors for the x, y, and z coordinates that will fill the position matrix within the model
x <- seq(1,10,1)*1e-3; y <- rep(0,10); z <- c(seq(1,5,1), rev(seq(1,5,1)))*1e-4
#Assign the radius vector
a <- z/2
#Assign material properties
g <- 1.036; h <- 1.0279
#Set curvature and radius of curvature
curve=T; pc=3.3
#Assign orientation
theta=90 #degrees
theta_rad <- degrad(theta, "deg") #convert from degrees to radians; model requires radians
#Fill out remaining parameters
c <- 1500 #m/s, sound speed
frequency <- 120e3 #Hz, transmit frequency
SDWBA(c=c, frequency=frequency, x=x, y=y, z=z, a=a, g=g, curve=curve, pc=pc, theta=theta_rad)
knitr::opts_chunk$set(echo = FALSE)
#We will use the same information we used before to generate our new scatterer
target <- FFSgenerate(x=x,y=y,z=z,a=a,g=g,h=h,curve=curve,pc=pc,theta=theta_rad)
devtools::install_github("brandynlucca/acousticTS@test-branch")
devtools::install_github("brandynlucca/acousticTS@test-branch", force=T)
?Shapely
require(acousticTS)
?Shapely
2 + 2
?SDWBA
target_premade
#We will call in a sample krill shape reported by McGehee et al. (1998) from the GitHub repository,
#but this can be applied to any *.csv file with the correct filepath.
target_premade <- FLSread("https://raw.githubusercontent.com/brandynlucca/acousticTS/test-branch/data/mcgehee.csv")
require(acousticTS)
#but this can be applied to any *.csv file with the correct filepath.
target_premade <- FLSread("https://raw.githubusercontent.com/brandynlucca/acousticTS/test-branch/data/mcgehee.csv")
#We can see that the file structure is the same as the previous "target" scatterer, just filled with different values
str(target_premade)
#Now let's run the model on the object
SDWBA(target_premade, c=c, frequency=frequency)
#We will call in a sample krill shape reported by McGehee et al. (1998) from the GitHub repository,
#but this can be applied to any *.csv file with the correct filepath.
target_premade <- FLSread("https://raw.githubusercontent.com/brandynlucca/acousticTS/test-branch/data/mcgehee.csv")
#We can see that the file structure is the same as the previous "target" scatterer, just filled with different values
str(target_premade)
#Now let's run the model on the object
SDWBA(target_premade, c=c, frequency=frequency)
target_premade <- FLSread("https://raw.githubusercontent.com/brandynlucca/acousticTS/test-branch/data/mcgehee.csv")
require(acousticTS)
target_premade <- FLSread("https://raw.githubusercontent.com/brandynlucca/acousticTS/test-branch/data/mcgehee.csv")
?FLSread
?plot
require(acousticTS)
?SDWBA
degrad(90, "deg")
?FLSread
knitr::opts_chunk$set(echo = FALSE)
#California krill
data(cakrill)
#E. pacifica
data(epac)
#N. difficilis
data(ndiff)
#T. spinifera
data(tspin)
cakrill
epac
ndiff
tspin
spp <- read.csv("C:/Users/Brandyn/Downloads/ALES.Summer_2019.CAKrill2019_IDs_raw.csv")
dir <- list.files("G:/CAkrill.2019/model_shapes/", full.names=T)
cakrill <- data.frame(x=c(), y=c(), z=c(), a=c(), h=c(), g=c(), seg=c())
epac <- cakrill
ndif <- cakrill
tspi <- cakrill
for(i in 1:length(dir)){
an <- strsplit(dir[i], split="[/|AN_,+]+")[[1]][6]
file <- read.csv(dir[i])
file$seg <- seq(1,nrow(file),1)
sp <- spp$Species[which(spp$Krill.ID. == an)]
if(sp == "N. difficilis"){
ndif <- rbind(ndif, file)
}else if(sp == "T. spinifera"){
tspi <- rbind(tspi, file)
}else if(sp == "E. pacifica"){
epac <- rbind(epac, file)
}
}
cakrill <- rbind(epac, ndif, tspi)
head(spp)
cakrill
cakrill %>% filter(seg == 1) %>% summarise(x=max(x))
require(dpluyr)
require(dplyr)
cakrill %>% filter(seg == 1) %>% summarise(x=max(x))
cakrill %>% filter(seg == 1) %>% summarise(x=mean(x), sd=sd(x))
cakrill %>% filter(seg == 1) %>% summarise(x=mean(x), sd=sd(x, na.rm=T))
cakrill %>% filter(seg == 1)
cakrill %>% filter(seg == 1) %>% summarise(xmean=mean(x), sd=sd(x, na.rm=T))
#Number of pulls
n <- 20
#CA
SDWBA(cakrill, c=c, frequency=frequency, lengths=rnorm(n,15.5,4.0)*1e-3, phase=0.2, theta=rnorm(n,0,32), parallel=T, aggregate="mean", curve=T)
n <- 20
#CA
SDWBA.sim(cakrill, c=c, frequency=frequency, lengths=rnorm(n,15.5,4.0)*1e-3, phase=0.2, theta=rnorm(n,0,32), parallel=T, aggregate="mean", curve=T)
?SDWBA.sim
tinytex::install_tinytex()
tinytex:::is_tinytex()
getwd()
setwd("C:/Users/Brandyn/Documents/GitHub/acousticTS")
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::install_github("brandynlucca/acousticTS@test-branch")
?SDWBA.sim
?SDWBA
?Shapely
devtools::install_github("brandynlucca/acousticTS@test-branch")
roxygen2::roxyenise()
roxygen2::roxygenize()
?FLS
---
title: "Using the SDWBA for krill in acousticTS"
author: "Brandyn M. Lucca"
date: "April 23, 2020"
output: slidy_presentation
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::knit_hooks$set(mysize = function(before, options, envir) {
if (before) {
return(options$size)
} else {
return("\\normalsize")
}
})
```
## acousticTS and SDWBA
- The purpose of `acousticTS` is the calculate the acoustic target strength (TS, dB re: m^2^) of a given scatterer, such as bubbles or euphausiids.
- Euphausiid TS is generally modelled using the distorted Born wave approximation (DWBA), which has numerous variants. We use a stochastic formulation (i.e., the SDWBA) to account for imperfections of animal shape and other non-linear effects of acoustic backscatter.
- This presentation will cover how to properly use `SDWBA(...)` and related wrapper functions for parameterizing euphausiid TS models.
## Package installation and setup
- `acousticTS` was built using R version 3.6.1, but requires a version > 3.4.3. The source code can be found at https://github.com/brandynlucca/acousticTS, which is continually updated and maintained.
- R is an open-source, statistical programming-language commonly used for data analysis across many fields. Updated versions of R can be installed on Windows, MacOS, and UNIX platforms from https://r-project.org.
- This package only has several dependencies that should automatically install alongside `acousticTS`: `elliptic` for the integration of complex numbers and `parallel`/`foreach`/`doParallel` for parallelized/vectorized computations to boost model performance.
## Package installation and set up
- To install the latest version of `acousticTS` from the GitHub repository, `devtools` is required:
```{r echo=T, warning=F, message=F}
#install.packages("devtools") #if needed, uncomment this line and install devtools
require(devtools)
install_github("brandynlucca/acousticTS")
#Call in the package to ensure it was properly installed
require(acousticTS)
```
- Full documentation is provided for all functions.
- Ex) `?SDWBA` provides the help documentation for how to properly use `SDWBA(...)`
## Model parameter definitions
- There are a number of parameters that are used to parameterize the `SDWBA(...)` and related functions.
+ `shape`: A customized `fluid-like scatterer (FLS)` (see: `?FLS`) class object that comprises metadata with respect to an animal's shape and material properties.
- `x`,`y`,`z`: the $x$, $y$, and $z$ coordinates (m) which make up the shape's position matrix, $r_0$.
- `a`: $a$, radius of each body segment (m).
- `g`: $g$, density contrast.
- `h`: $h$, sound speed contrast.
- `ncyl`: $N$, the number of segments that make up the shape.
- `L`: the length of the animal (m).
+ `c`: $c$, ambient seawater sound speed (m/s).
+ `frequency`: transmitted frequency (Hz).
+ `phase`: $\phi$, a stochastic phase variability term.
+ `curve`: a boolean term that informs the model whether the animal's body is curved or not.
+ `pc`: $\rho_c$, the ratio of how curved an animal is to its body length.
+ `theta:` $\theta$, animal orientation relative to the transducer where broadside incidence is 90$^\circ$/270$^\circ$. Note that the model requires $\theta$ to be in radians.
## Model functions that will be used
- There are a number of functions that will be used in this presentation. Additional information is available in each function's respective documentation.
+ `data(...)`: Generic R-function to call in specific shapefiles.
+ `FLSgenerate(...)`: Manually generate a `FLS` shape.
+ `FLSread(...)`: Read in a *.csv file containing a `FLS` shape.
+ `FLSwrite(...)`: Manually create a *.csv file containing a `FLS` shape.
+ `degrad(...)`: Change from radians to degrees, and vice versa.
+ `Shapely(...)`: Manipulate an animal shape by changing curvature, $\rho_c$, $L$/$r_0$, and $\theta$.
+ `SDBWA(...)`: Calculates the theoretical TS of a fluid-like scatterer at a given frequency using the SDWBA model.
+ `SDWBA.sim(...)`: Calculates the theoretical TS of a fluid-like scatterer using the SDWBA model over distributions of parameter inputs.
## Model syntax and setup
- We can generate a shape one of four ways:
1. Manually parameterizing the model.
2. Creating an FLS-object.
3. Calling in a pre-made FLS-object.
4. Mixing both manual and pre-made parameter inputs.
## Model syntax and setup
Manually parameterizing the model.
+ Here create random inputs based on whatever arbitrary values we want to parameterize the `SDWBA(...)` function.
```{r echo=T, warnings=F, message=F}
#Create vectors for the x, y, and z coordinates that will fill the position matrix within the model
x <- seq(1,10,1)*1e-3; y <- rep(0,10); z <- c(seq(1,5,1), rev(seq(1,5,1)))*1e-4
#Assign the radius vector
a <- z/2
#Assign material properties
g <- 1.036; h <- 1.0279
#Set curvature and radius of curvature
curve=T; pc=3.3
#Assign orientation
theta=90 #degrees
theta_rad <- degrad(theta, "deg") #convert from degrees to radians; model requires radians
#Fill out remaining parameters
c <- 1500 #m/s, sound speed
frequency <- 120e3 #Hz, transmit frequency
#Now let's calculate the TS using SDWBA
SDWBA(c=c, frequency=frequency, x=x, y=y, z=z, a=a, g=g, h=h, curve=curve, pc=pc, theta=theta_rad)
```
## Model syntax and setup
Generate a FLS object.
- This is required for some functions, such as `Shapely(...)` and works better than manual inputs for `SDWBA(...)` and `SDWBA.sim(...)`.
```{r echo=T, warnings=F, message=F}
#We will use the same information we used before to generate our new scatterer
target <- FLSgenerate(x=x,y=y,z=z,a=a,g=g,h=h,curve=curve,pc=pc,theta=theta_rad)
#We can look at the structure to get an idea about what the FLS scatterer object
#looks like
str(target)
#Now let's run the model on the object
SDWBA(target, c=c, frequency=frequency)
```
## Model syntax and setup
Calling in a .csv formatted file to gneerate a FLS-object.
- This will call in an FLS-formatted .csv file that matches the format reported by McGehee *et al.* (1998). This example will use the built-in sample dataset reported in McGehee *et al.* for *Euphausia superba*.
```{r echo=T}
#We will call in a sample krill shape reported by McGehee et al. (1998) from the GitHub repository,
#but this can be applied to any *.csv file with the correct filepath.
target_premade <- FLSread("https://raw.githubusercontent.com/brandynlucca/acousticTS/test-branch/data-raw/mcgehee.csv")
#We can see that the file structure is the same as the previous "target" scatterer, just filled with different values
str(target_premade)
#Now let's run the model on the object
SDWBA(target_premade, c=c, frequency=frequency)
```
## Model syntax and setup
Combining both arbitrary and pre-made FLS-object parameters.
```{r echo=T}
#Let's say we are interested in a very different set of material properties
SDWBA(target_premade, c=c, frequency=frequency, g=1.01, h=1.005)
```
## FLS-object manipulation
What if we want to change $\theta$, $\rho_c$, $L$, and if our animal is curved? We can use the `Shapely(...)` function to achieve this.
```{r echo=T}
#Let's use our previous example shape and change the length, curvature, and orientation
target_manip <- Shapely(target_premade, curve=T, pc=3.3, theta=pi/4, length=20*1e-3)
#So we can force the object to do our bidding.
str(target_manip)
#Now let's calculate TS
SDWBA(target_manip, c=c, frequency=frequency)
```
## Stochastic phase term
Up until now, we have not added in the phase deviation term ($\phi$) that is set via `SDWBA(..., phase=0.0)`. As noted, this sets the standard deviation term to draw from a standard normal distribution that is drawn from `rnorm(1,0,phase)`. We can see that this can have a negligible-to-large effect depending on how large $\phi$ is set.
```{r echo=T}
set.seed(1000)
#Normal DWBA, phase = 0.0
SDWBA(target_manip, c=c, frequency=frequency)
#phase = 0.22
SDWBA(target_manip, c=c, frequency=frequency, phase=0.22)
#phase = 0.77
SDWBA(target_manip, c=c, frequency=frequency, phase=0.71)
```
## Stochastic phase term
Because this is a stochastic variable, it makes more sense to simulate over more than a single iteration. This can be achieved using `SDWBA.sim(...)` (see: `?SDWBA.sim`), specifically defining `SDWBA.sim(..., nrep=...)`:
```{r echo=T}
#Let's generate 10 iterations using the phase deviation, phi, of 0.71.
#This will print a bunch of values with their respective parameters.
set.seed(1000)
SDWBA.sim(target_manip, c=c, frequency=frequency, phase=0.71, nrep=5)
```
## Parallelization
`SDWBA.sim(...)` can take a long time to compute models the more dimensions you add to each parameter. This function has been built to support multicore support via `SDWBA.sim(..., parallel=T)` and defining the number of CPU cores you'd like to allocate to the function via `SDWBA.sim(..., n.cores=...)`.
```{r echo=T, message=F, warnings=F}
#Parallelized
set.seed(1000)
SDWBA.sim(target_manip, c=c, frequency=frequency, phase=0.71, nrep=5, parallel=T, n.cores=6)
```
## Aggregating results
The output of `SDWBA.sim(...)` is by default a data.frame; however, if only a single aggregate statistic is needed, then `SDWBA.sim(..., aggregate=c("mean","median","maximum","minimum"))` can be used to generate just the mean, median, maximum, minimum, or any combination of those descriptive statistics.
```{r echo=T}
#Run model and generate descriptive statistics for output.
SDWBA.sim(target_manip, c=c, frequency=frequency, phase=0.71, nrep=5, parallel=T, n.cores=6, aggregate=c("mean","median","maximum","minimum"))
```
## Simulating model parameters
We can also pull values from distributions and vary our model inputs. This will generate every combination of inputs.
```{r echo=T, message=F}
#Using our same animal, let's play around with a few distributions
set.seed(1250)
n <- 5 #number of animal parameters we want to simulate
lengths <- rnorm(n,mean=30,sd=5)*1e-3 #Normal distribution of lengths
g <- rnorm(n,mean=target_manip@g,sd=1e-3) #Normal distribution for g
h <- rnorm(n,mean=target_manip@h,sd=1e-3) #Normal distribution for h
theta <- c(pi/2,pi/4) #Play around with two different orienation angles
pd <- 0.71 #phase deviation
#Let's run the model
ts_sim <- SDWBA.sim(target_manip, c=c, frequency=frequency, phase=pd, g=g, h=h, length=lengths, parallel=T)
head(ts_sim)
```
## Example: Generate a TS-frequency spectrum for a single animal
We can do other things like generating TS-frequency spectra to compare and contrast different parameters.
```{r echo=T, message=F, eval=F}
#We will compare the TS-frequency spectra of the same target when it is curved and non-curved
curve = c(T,F) #curved and non-curved
freq <- seq(10,300,10)*1e3 #frequencies to simulate, Hz
theta <- pi/2 #broadside incidence
ts_freq <- SDWBA.sim(target_manip, c=c, frequency=freq, curve=curve, theta=theta, parallel=T)
#And we can plot!
require(ggplot2)
ggplot(data=ts_freq, aes(y=TS,x=frequency*1e-3)) + geom_path(aes(color=curve), size=2) +
theme_bw() + theme(text=element_text(size=16), axis.text=element_text(size=14, color="black"),
panel.grid=element_blank()) +
scale_color_manual(values=c("red","blue"), labels=c("Straight","Curved")) +
labs(y=expression(paste("Target strength (dB re: 1 ",m^2,")")),
x="Frequency (kHz)", color="")
```
## Model recommendations
Summary of SDWBA model inputs for each krill species with distributions reported where appropriate.
Parameters | *E. pacifica* | *N. difficilis* | *T. spinifera*
------------- | ------------- | ------------- | -------------
Shape | Specific | Specific | Specific
$L$ | N(14.3,3.4) | N(16.6, 2.4) | N(18.8, 2.9)
$g$ | N(1.0299,0.0082) | N(1.0269,0.0099) | N(1.0621,0.0078)
$h$ | N(1.0233,0.0086) | N(1.0233,0.0086) | N(1.0233,0.0086)
$\rho_c$ | 3.3 | 3.3 | 3.3
$\theta$ | N(0,32) | N(0,32) | N(0,32)
$\phi$ | 0.2 | 0.2 | 0.2
For shape, we have provided a generic California krill, as well as species-specific shapes. These can be called in via:
```{r echo=T, eval=F}
#California krill
data(cakrill)
#E. pacifica
data(epac)
#N. difficilis
data(ndiff)
#T. spinifera
data(tspin)
```
## Model recommendations
So if we want to parameterize our models, we can:
```{r, echo=T}
#Number of pulls
n <- 20
#CA
SDWBA.sim(cakrill, c=c, frequency=frequency, length=rnorm(n,15.5,4.0)*1e-3, phase=0.2, theta=rnorm(n,0,32), parallel=T, aggregate="mean", curve=T)
#Epac
SDWBA.sim(epac, c=c, frequency=frequency, length=rnorm(n,15.5,4.0)*1e-3, phase=0.2, theta=rnorm(n,0,32), parallel=T, aggregate="mean", curve=T)
#Tspin
SDWBA.sim(tspin, c=c, frequency=frequency, length=rnorm(n,15.5,4.0)*1e-3, phase=0.2, theta=rnorm(n,0,32), parallel=T, aggregate="mean", curve=T)
#Ndiff
SDWBA.sim(ndiff, c=c, frequency=frequency, length=rnorm(n,15.5,4.0)*1e-3, phase=0.2, theta=rnorm(n,0,32), parallel=T, aggregate="mean", curve=T)
```
## Things to consider
- It's important to to scrutinize the model outputs.
+ When simulating TS... look at the histogram/distribution of the output. Are there extreme values? Does the distribution look skewed one way or another?
- Consider whether it's more important to capture krill in general (i.e., generic California krill shape) or specify a single species (i.e., each individual species shape).
- Our parameter distributions were based on samples we used in our experiments.
+ It is likely more appropriate to draw lengths from more robust net tow data.
+ There can be variability in animal shape, so the generic shapes provided by this study can be built upon by importing more shape data from future cruises.
## Next steps
- Get the model into your hands so it can be played around with.
+ What functionality can be added or improved for your use?
+ Are things broken?
+ Are things unclear?
- Figure out a date for a follow-up meeting for a more thorough code walkthrough/troubleshooting session, if desired.
