an <- ((2*i-1)*cos(theta)*a1 - (i+kappa-1)*a0) / i
bn <- ((2*i-1)*cos(theta)*b1 - (i+kappa-1)*b0) / i
sn <- an * s1 - bn * s0
# Check for convergence using the relative tolerance
if (abs(sn) < tol * max(abs(s0), abs(s1))) {
break
}
s0 <- s1
s1 <- sn
a0 <- a1
a1 <- an
b0 <- b1
b1 <- bn
}
# Return the final value of the angular spheroidal function
return(s1)
}
)
# Compute the angular spheroidal function of the first kind for a given n, kappa, and theta
spheroidal_ps <- function(n, kappa, theta) {
# Set the tolerance for the recursion
tol <- 1e-12
# Set the maximum number of iterations for the recursion
max_iter <- 1000
# Initialize the recursion coefficients
a0 <- 1
a1 <- cos(theta)
b0 <- 0
b1 <- -kappa * sin(theta)
# Initialize the values of the angular spheroidal function for n=0 and n=1
s0 <- a0
s1 <- a0 * (kappa^2 - n^2) + a1 * kappa * sin(theta)
# Compute the values of the angular spheroidal function for n >= 2 using the recurrence relation
for (i in 2:n) {
an <- ((2*i-1)*cos(theta)*a1 - (i+kappa-1)*a0) / i
bn <- ((2*i-1)*cos(theta)*b1 - (i+kappa-1)*b0) / i
sn <- an * s1 - bn * s0
# Check for convergence using the relative tolerance
if (abs(sn) < tol * max(abs(s0), abs(s1))) {
break
}
s0 <- s1
s1 <- sn
a0 <- a1
a1 <- an
b0 <- b1
b1 <- bn
}
# Return the final value of the angular spheroidal function
return(s1)
}
spheroidal_ps(1,1,2,0.5)
spheroidalWaveFunction( 3 , 2 , 1 , 0.5)
spheroidal_coefficients( 3 , 2 , 0.5 )
# Compute the prolate spheroidal wave function of the first kind for a given m, n, gamma, and z
prolate_spheroidal_ps <- function(m, n, gamma, z) {
# Set the number of terms to use in the summation
N <- 100
# Compute the constant factor
const <- sqrt(pi) * 2^(m+1) * gamma(n+m+1) / (factorial(n) * gamma(m+0.5))
# Initialize the sum
sum <- 0
# Compute the terms of the summation
for (k in 0:(N-1)) {
term <- (-1)^k * gamma(n+m-k+1) / (factorial(k) * factorial(n-k) * gamma(m+k+0.5)) * (z/2)^(2*k)
sum <- sum + term
}
# Compute the value of the prolate spheroidal wave function
value <- const * z^(m+0.5) * sum
return(value)
}
prolate_spheroidal_ps(3,2,1,0.5)
# Define the function for the Jacobi polynomial
jacobi_polynomial <- function(n, alpha, beta, x) {
if (n == 0) {
return(1)
} else if (n == 1) {
return(0.5 * (alpha - beta + (alpha + beta + 2) * x))
} else {
a1 <- (beta^2 - alpha^2) / ((2*n + alpha + beta) * (2*n + alpha + beta - 2))
a2 <- (4 * n * (n + alpha) * (n + beta) * (n + alpha + beta)) /
((2*n + alpha + beta)^2 * (2*n + alpha + beta - 2)^2 * (2*n + alpha + beta - 1))
pnm1 <- jacobi_polynomial(n - 1, alpha, beta, x)
pnm2 <- jacobi_polynomial(n - 2, alpha, beta, x)
return(((2*n + alpha + beta - 1) * ((alpha + beta)*x + alpha - beta) * pnm1 -
(n + alpha - 1)*(n + beta - 1)*pnm2) / (2*n + alpha + beta)*(a1 + a2*(1-x^2)))
}
}
# Compute the prolate spheroidal wave function of the first kind for a given m, n, alpha, and x
prolate_spheroidal_ps <- function(m, n, alpha, x) {
# Set the tolerance for the recursion
tol <- 1e-12
# Set the maximum number of iterations for the recursion
max_iter <- 1000
# Initialize the coefficients
a0 <- 1
a1 <- x + alpha
# Initialize the values of the prolate spheroidal function for n=0 and n=1
s0 <- a0
s1 <- a1 * s0 - m * (m + alpha) * a0
# Compute the values of the prolate spheroidal function for n >= 2 using the recurrence relation
for (i in 2:n) {
an <- ((2*i + alpha - 1) * (x + alpha) * a1 - i*(i + alpha + m - 1) * a0) / (i*(i + alpha))
a0 <- a1
a1 <- an
sn <- a1 * s1 - (i + m) * (i + alpha + m - 1) * s0
s0 <- s1
s1 <- sn
}
# Compute the normalization constant
norm_const <- sqrt(gamma(n + m + 1) * (n - m + alpha) / (n + m + alpha + 1) / gamma(n - m + 1))
# Compute the value of the prolate spheroidal wave function
value <- norm_const * jacobi_polynomial(m, alpha, n - m + alpha, x) * s1
return(value)
}
prolate_spheroidal_ps(3,2,1,0.5)
# Define a function to compute the gamma function using the Lanczos approximation
gamma_function <- function(z) {
# Set the coefficients for the Lanczos approximation
coef <- c(0.99999999999980993, 676.5203681218851, -1259.1392167224028,
771.32342877765313, -176.61502916214059, 12.507343278686905,
-0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7)
# Compute the value of the gamma function
g <- 7
if (z < 0.5) {
return(pi / (sin(pi * z) * gamma_function(1 - z)))
} else {
z <- z - 1
x <- coef[1]
for (i in 2:length(coef)) {
x <- x + coef[i] / (z + i - 1)
}
t <- z + g + 0.5
value <- sqrt(2 * pi) * t^(z + 0.5) * exp(-t) * x
return(value)
}
}
# Define a function to compute the prolate spheroidal wave function of the first kind using the recurrence relation
prolate_spheroidal_wave_function <- function(n, m, gamma, x) {
# Set the tolerance for the recursion
tol <- 1e-12
# Set the maximum number of iterations for the recursion
max_iter <- 1000
# Initialize the coefficients
a0 <- 1
a1 <- x + gamma
# Initialize the values of the prolate spheroidal function for n=0 and n=1
s0 <- a0
s1 <- a1 * s0 - m * (m + gamma) * a0
# Compute the values of the prolate spheroidal function for n >= 2 using the recurrence relation
for (i in 2:n) {
an <- ((2*i + gamma - 1) * (x + gamma) * a1 - i*(i + gamma + m - 1) * a0) / (i*(i + gamma))
a0 <- a1
a1 <- an
sn <- a1 * s1 - (i + m) * (i + gamma + m - 1) * s0
s0 <- s1
s1 <- sn
}
# Compute the normalization constant
norm_const <- sqrt((2 * n + 1) / (gamma * gamma * (n + gamma + 1) * gamma_function(n + m + 1)))
# Compute the value of the prolate spheroidal wave function
value <- norm_const * s1
return(value)
}
# Define the pro_rad1 function as a wrapper around the prolate_spheroidal_wave_function function
pro_rad1 <- function(a, b, x) {
# Set the tolerance for the recursion
tol <- 1e-12
# Set the maximum number of iterations for the recursion
max_iter <- 1000
# Compute the value of gamma
gamma <- sqrt(a^2 - b^2)
# Compute the value of the radial spheroidal wave function
value <- prolate_spheroidal_wave_function(b, 0, gamma, x)
return(value)
}
pro_rad1(3,2,1,0.5)
pro_rad1
sp$special$pro_rad1(3,2,0.5)
sp$special$pro_rad1(3,2,1,0.5)
sp$special$pro_ang1(3,2,1,0.5)
sp$special$pro_ang1(2,3,1,0.5)
sp$special$pro_ang1(2,3,1,0.5)
sp$special$pro_ang1(2,3,1,0.5)
sp$special$pro_ang1(2,3,1,0.5)
sp$special$pro_ang1(3,2,1,0.5)
sp$special$pro_ang1(3,1,1,0.5)
sp$special$pro_ang1(3,1,2,0.5)
sp$special$pro_ang1(1,1,2,0.5)
sp$special$pro_ang1(1,2,2,0.5)
sp$special$pro_ang1(1,2,3,0.5)
sp$special$pro_ang1(3,2,1,0.5)
sp$special$pro_ang1(2,3,1,0.5)
an := 1
# Define a function to compute the angular spheroidal wave function of the first kind using the pro_rad1 algorithm
pro_rad1 <- function(n, m, gamma, z) {
# Compute the value of the gamma function
gamma_func <- function(x) {
if (x < 0.5) {
pi / (sin(pi * x) * gamma_func(1 - x))
} else {
temp <- x - 1
p <- 1.000000000190015
p += 76.18009172947146 / temp
p += -86.50532032941677 / (temp + 1)
p += 24.01409824083091 / (temp + 2)
p += -1.231739572450155 / (temp + 3)
p += 0.001208650973866179 / (temp + 4)
p += -0.000005395239384953 / (temp + 5)
2.5066282746310005 * sqrt(2 * pi) * exp((temp + 0.5) * log(temp + 5.5) - (temp + 5.5) + log(p))
}
}
g <- sqrt(gamma^2 - m^2)
gc <- gamma / g
gs <- m / g
gsp <- g / gamma
norm_factor <- sqrt((2 * n + 1) * gamma_func(n + m + 1) / (2 * gamma))
an <- 1
anp <- z - (n - 1) * gc
bn <- z
bnp <- z - (n - 1) * gs
for (k in 2:n) {
ak <- (z + (k - 1) * g) * anp - (k - 1) * gsp * an
akp <- (z + (k - 1) * g) * ak - n * (n + 1) * an
bk <- (z + (k - 1) * gs) * bnp - (k - 1) * gsp * bn
bkp <- (z + (k - 1) * gs) * bk - n * (n + 1) * bn
an <- ak
anp <- akp
bn <- bk
bnp <- bkp
}
return(norm_factor * an)
}
# Define a function to compute the angular spheroidal wave function of the first kind using the pro_rad1 algorithm
pro_rad1 <- function(n, m, gamma, z) {
# Compute the value of the gamma function
gamma_func <- function(x) {
if (x < 0.5) {
pi / (sin(pi * x) * gamma_func(1 - x))
} else {
temp <- x - 1
p <- 1.000000000190015
p += 76.18009172947146 / temp
p += -86.50532032941677 / (temp + 1)
p += 24.01409824083091 / (temp + 2)
p += -1.231739572450155 / (temp + 3)
p += 0.001208650973866179 / (temp + 4)
p += -0.000005395239384953 / (temp + 5)
2.5066282746310005 * sqrt(2 * pi) * exp((temp + 0.5) * log(temp + 5.5) - (temp + 5.5) + log(p))
}
}
g <- sqrt(gamma^2 - m^2)
gc <- gamma / g
gs <- m / g
gsp <- g / gamma
norm_factor <- sqrt((2 * n + 1) * gamma_func(n + m + 1) / (2 * gamma))
an <- 1
anp <- z - (n - 1) * gc
bn <- z
bnp <- z - (n - 1) * gs
for (k in 2:n) {
ak <- (z + (k - 1) * g) * anp - (k - 1) * gsp * an
akp <- (z + (k - 1) * g) * ak - n * (n + 1) * an
bk <- (z + (k - 1) * gs) * bnp - (k - 1) * gsp * bn
bkp <- (z + (k - 1) * gs) * bk - n * (n + 1) * bn
an <- ak
anp <- akp
bn <- bk
bnp <- bkp
}
return(norm_factor * an)
}
# Define a function to compute the angular spheroidal wave function of the first kind using the pro_rad1 algorithm
pro_rad1 <- function(n, m, gamma, z) {
# Compute the value of the gamma function
gamma_func <- function(x) {
if (x < 0.5) {
pi / (sin(pi * x) * gamma_func(1 - x))
} else {
temp <- x - 1
p <- 1.000000000190015
p += 76.18009172947146 / temp
p += -86.50532032941677 / (temp + 1)
p += 24.01409824083091 / (temp + 2)
p += -1.231739572450155 / (temp + 3)
p += 0.001208650973866179 / (temp + 4)
p += -0.000005395239384953 / (temp + 5)
2.5066282746310005 * sqrt(2 * pi) * exp((temp + 0.5) * log(temp + 5.5) - (temp + 5.5) + log(p))
}
}
g <- sqrt(gamma^2 - m^2)
gc <- gamma / g
gs <- m / g
gsp <- g / gamma
norm_factor <- sqrt((2 * n + 1) * gamma_func(n + m + 1) / (2 * gamma))
an <- 1
anp <- z - (n - 1) * gc
bn <- z
bnp <- z - (n - 1) * gs
for (k in 2:n) {
ak <- (z + (k - 1) * g) * anp - (k - 1) * gsp * an
akp <- (z + (k - 1) * g) * ak - n * (n + 1) * an
bk <- (z + (k - 1) * gs) * bnp - (k - 1) * gsp * bn
bkp <- (z + (k - 1) * gs) * bk - n * (n + 1) * bn
an <- ak
anp <- akp
bn <- bk
bnp <- bkp
}
return(norm_factor * an)
}
# Define a function to compute the angular spheroidal wave function of the first kind using the pro_rad1 algorithm
pro_rad1 <- function(n, m, gamma, z) {
# Compute the value of the gamma function
gamma_func <- function(x) {
if (x < 0.5) {
pi / (sin(pi * x) * gamma_func(1 - x))
} else {
temp <- x - 1
p <- 1.000000000190015
p += 76.18009172947146 / temp
p += -86.50532032941677 / (temp + 1)
p += 24.01409824083091 / (temp + 2)
p += -1.231739572450155 / (temp + 3)
p += 0.001208650973866179 / (temp + 4)
p += -0.000005395239384953 / (temp + 5)
2.5066282746310005 * sqrt(2 * pi) * exp((temp + 0.5) * log(temp + 5.5) - (temp + 5.5) + log(p))
}
}
g <- sqrt(gamma^2 - m^2)
gc <- gamma / g
gs <- m / g
gsp <- g / gamma
norm_factor <- sqrt((2 * n + 1) * gamma_func(n + m + 1) / (2 * gamma))
an <- 1
anp <- z - (n - 1) * gc
bn <- z
bnp <- z - (n - 1) * gs
for (k in 2:n) {
ak <- (z + (k - 1) * g) * anp - (k - 1) * gsp * an
akp <- (z + (k - 1) * g) * ak - n * (n + 1) * an
bk <- (z + (k - 1) * gs) * bnp - (k - 1) * gsp * bn
bkp <- (z + (k - 1) * gs) * bk - n * (n + 1) * bn
an <- ak
anp <- akp
bn <- bk
bnp <- bkp
}
return(norm_factor * an)
}
# Define a function to compute the angular spheroidal wave function of the first kind using the pro_rad1 algorithm
pro_rad1 <- function(n, m, gamma, z) {
# Compute the value of the gamma function
gamma_func <- function(x) {
if (x < 0.5) {
pi / (sin(pi * x) * gamma_func(1 - x))
} else {
temp <- x - 1
p <- 1.000000000190015
p += 76.18009172947146 / temp
p += -86.50532032941677 / (temp + 1)
p += 24.01409824083091 / (temp + 2)
p += -1.231739572450155 / (temp + 3)
p += 0.001208650973866179 / (temp + 4)
p += -0.000005395239384953 / (temp + 5)
2.5066282746310005 * sqrt(2 * pi) * exp((temp + 0.5) * log(temp + 5.5) - (temp + 5.5) + log(p))
}
}
g <- sqrt(gamma^2 - m^2)
gc <- gamma / g
gs <- m / g
gsp <- g / gamma
norm_factor <- sqrt((2 * n + 1) * gamma_func(n + m + 1) / (2 * gamma))
an <- 1
anp <- z - (n - 1) * gc
bn <- z
bnp <- z - (n - 1) * gs
for (k in 2:n) {
ak <- (z + (k - 1) * g) * anp - (k - 1) * gsp * an
akp <- (z + (k - 1) * g) * ak - n * (n + 1) * an
bk <- (z + (k - 1) * gs) * bnp - (k - 1) * gsp * bn
bkp <- (z + (k - 1) * gs) * bk - n * (n + 1) * bn
an <- ak
anp <- akp
bn <- bk
bnp <- bkp
}
return(norm_factor * an)
}
p = 1
p += 1
# Define a function to compute the angular spheroidal wave function of the first kind using the pro_rad1 algorithm
pro_rad1 <- function(n, m, gamma, z) {
# Compute the value of the gamma function
# Define a function to compute the value of the gamma function
gamma_function <- function(x) {
if (x < 0.5) {
pi / (sin(pi * x) * gamma_function(1 - x))
} else {
temp <- x - 1
p <- 1.000000000190015
p = p + 76.18009172947146 / temp
p = p - 86.50532032941677 / (temp + 1)
p = p + 24.01409824083091 / (temp + 2)
p = p - 1.231739572450155 / (temp + 3)
p = p + 0.001208650973866179 / (temp + 4)
p = p - 0.000005395239384953 / (temp + 5)
2.5066282746310005 * sqrt(2 * pi) * exp((temp + 0.5) * log(temp + 5.5) - (temp + 5.5) + log(p))
}
}
g <- sqrt(gamma^2 - m^2)
gc <- gamma / g
gs <- m / g
gsp <- g / gamma
norm_factor <- sqrt((2 * n + 1) * gamma_function(n + m + 1) / (2 * gamma))
an <- 1
anp <- z - (n - 1) * gc
bn <- z
bnp <- z - (n - 1) * gs
for (k in 2:n) {
ak <- (z + (k - 1) * g) * anp - (k - 1) * gsp * an
akp <- (z + (k - 1) * g) * ak - n * (n + 1) * an
bk <- (z + (k - 1) * gs) * bnp - (k - 1) * gsp * bn
bkp <- (z + (k - 1) * gs) * bk - n * (n + 1) * bn
an <- ak
anp <- akp
bn <- bk
bnp <- bkp
}
return(norm_factor * an)
}
pro_rad1(2,3,1,0.5)
pro_rad1(3,2,1,0.5)
pro_rad1(1,2,3,0.5)
sp$special$pro_rad1(2,3,1,0.5)
sp$special$pro_rad1(1,2,3,0.5)
sp$special$pro_rad1(2,3,1,0.5)
sp$special$pro_rad1(3,2,1,0.5)
sp$special$pro_rad1(1,2,1,0.5)
sp$special$pro_rad1(1,1,1,0.5)
sp$special$pro_rad1(1,1,1,0.5)
sp$special$pro_rad1(1,0,2.5,1)
sp$special$pro_rad1(0,1,2.5,1)
sp$special$pro_rad1(1,2.5,1)
sp$special$pro_rad1(0,1,2.5,1)
sp$special$pro_rad1( 2, 1 , 2.5, 1 )
sp$special$pro_rad1( 0, 1, 2.5, 1)
sp$special$pro_rad1( 0, 1, 0.5, 1)
sp$special$pro_rad1( 0, 1, 0.5, 0/5)
sp$special$pro_rad1( 0, 1, 1, 0/5)
sp$special$pro_rad1( 0, 0, 0, 0)
sp$special$pro_rad2( 0, 0, 0, 0)
sp$special$pro_rad2( 0, 1, 0, 0)
sp$special$pro_rad2( 0, 1, 0, 1)
sp$special$pro_rad2( 0, 1, 0, 0.5)
sp$special$pro_rad2( 0, 1, 0.1, 0.5)
sp$special$pro_rad2( 0.1, 1, 0.1, 0.5)
sp$special$pro_rad2( 1, 1, 0.1, 0.5)
sp$special$pro_rad1(0,2,.25,-0.5)
sp$special$pro_rad1(0,2,.25,0.5)
sp$special$pro_rad1(0,2,.25,1.5)
pro_rad1(0,2,.25,1.5)
pro_rad1(2,0,.25,1.5)
pro_rad1(2,0,.25,1.5)
pro_rad1(0,2,.25,1.5)
sp$special$pro_rad1(0,1,2.5,1)
sp$special$pro_rad1(0,1,2.5,1.001)
sp$special$pro_rad1(0,1,2.5,1.00000000001)
sp$special$pro_rad1(0,1,2.5,1.000000000000001)
pro_rad1(1,0,2.5,1.00000001)
pro_rad1(1,0,2.5,1.0000000000001)
pro_rad1(0,1,2.5,1.0000000000001)
pro_rad1
ASWFA <- function(Z, A, B, C, M, N) {
# Compute spheroidal wave functions of the first kind of orders M and M+1
# and degrees N and N+1 associated with prolate symmetry, evaluated at a
# point Z = (X^2 + Y^2) / C^2.
# The constants A, B, and C are given by:
#   A^2 = X^2 + Y^2 + Z^2 - C^2
#   B^2 = C^2 - A^2
# Set up initial values
F <- 0
G <- 0
H <- 0
if (Z < 0) {
# Return 0 if Z is negative
return(c(F, G, H))
}
T1 <- A + C
T2 <- A - C
if (abs(T2) < 1e-10) {
T2 <- T2 + T2^2 * 1e-10
}
T3 <- 1 / T2
T4 <- 2 * A * T1 * T3
T5 <- 2 * B * T3
T6 <- (C^2 - A^2 - B^2) / (2 * C * B)
T7 <- (M + 1) * T6
T8 <- (N + 1) * T6
# Compute spheroidal wave functions of the first kind using recurrence relations
for K in 1:(N - M) {
T9 <- (K + M) * (K + M + 1) * T3 - T1 * T4
T10 <- (K + 1) * T5
F <- T10 - T9 * F
T11 <- K * (N + M + K) * T3 - T1 * T6
G <- T10 - T11 * G
T12 <- K * (K - 1) * T3 + (N + M + K) * T6
H <- T10 - T12 * H
}
# Return the computed spheroidal wave functions
return(c(F, G, H))
}
