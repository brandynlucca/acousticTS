#Calculate theoretical TS frequency spectrum for a calibration sphere
sphere.ts <- function(frequency,c,rho,material="Tungsten carbide",diameter=38.1){
sphere_mat <- sphere_param(material) #call sphere material properties
a <- diameter*1e-3/2 #calculate radius; convert from diameter to radius; m
alpha <- 2*(as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c2"]])/c)^2 #Equation 6d
beta <- (as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c1"]])/c)^2 - alpha #Equation 6e
k <- 2*pi*frequency/c #acoustic wavenumber
q <- k*a #ka variable; Equation 6a
q1 <- q * c / as.numeric(sphere_mat[["c1"]]) #Equation 6a
q2 <- q * c / as.numeric(sphere_mat[["c2"]]) #Equation 6a
return(TS_calculate(q,q1,q2,alpha,beta,a))
}
#' Calculate the acoustic target strength (TS, dB re: 1 m^2) of an elastic sphere of a certain material at a given frequency.
#'
#' @description
#' This function is a wrapper around TS_calculate(...) that parametrizes the remainder of the model, while also doing
#' simple calculations that do not need to be looped. This function provides a mean TS which includes a FM sweep around
#' a center frequency. This is calculated by adding and subtracting half an estimated bandwidth (1/pulse length) and taking
#' the mean (calculated in the linear domain).
#'
#' @param frequency The acoustic frequency (Hz)
#' @param c The ambient seawater sound speed (m/s).
#' @param rho The ambient seawater density (kg/m^3).
#' @param material The material of the calibration sphere (tungsten carbide, aluminum, stainless steel, copper)
#' @param diameter The diameter of the sphere (mm).
#' @param pulse_length The pulse length (microseconds) of a signal.
#' @examples
#' frequency <- 120e3
#' c <- 1500
#' rho <- 1030
#' material <- "Tungsten carbide"
#' diameter <- 38.1
#' pulse_length <- 256
#' sphere.cw(frequency,c,rho,material,diameter,pulse_length)
#' [1] -39.549
#' @return The theoretical acoustic target strength (TS, dB re: 1 m^2) of
#'    an elastic sphere at a given frequency and pulse length.
#' @export
#Calculate theoretical TS frequency spectrum for a calibration sphere
sphere.cw <- function(frequency,c,rho,material="Tungsten carbide",diameter=38.1,pulse_length){
bandwidth <- 1/(pulse_length/1e6) #BW = 1/pulse length, pulse length here is converted to seconds
fs <- frequency - bandwidth/2 #frequency start
fe <- frequency + bandwidth/2 #frequency end
cw_spec <- seq(fs,fe,length.out=100) #calculate frequency spectrum with 100 steps
sphere_mat <- sphere_param(material) #call sphere material properties
a <- diameter*1e-3/2 #calculate radius; convert from diameter to radius; m
alpha <- 2*(as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c2"]])/c)^2 #Equation 6d
beta <- (as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c1"]])/c)^2 - alpha #Equation 6e
ts <- rep(NA,length(cw_spec)) #pre-allocate ts vector to calculate average
pb <- winProgressBar(title="Processing frequencies...", label="0% completed", min=0, max=100, initial=0)
for(i in 1:length(cw_spec)){
k <- 2*pi*cw_spec[i]/c #acoustic wavenumber
q <- k*a #ka variable; Equation 6a
q1 <- q * c / as.numeric(sphere_mat[["c1"]]) #Equation 6a
q2 <- q * c / as.numeric(sphere_mat[["c2"]]) #Equation 6a
ts[i] <- TS_calculate(q,q1,q2,alpha,beta,a)
load.info <- sprintf("%d%% completed", round((i/length(ts))*100))
setWinProgressBar(pb, i/(length(ts))*100, label=load.info)
}
close(pb)
return(10*log10(mean(10^(ts/10)))) #calculate average in linear domain
}
#' Calculate the frequency spectrum of the acoustic target strength (TS, dB re: 1 m^2) of an elastic sphere .
#'
#' @description
#' This function is a wrapper around TS_calculate(...) that parametrizes the remainder of the model, while also doing
#' simple calculations that do not need to be looped. This function provides TS estimates along a frequency spectrum.
#'
#' @param c The ambient seawater sound speed (m/s).
#' @param rho The ambient seawater density (kg/m^3).
#' @param material The material of the calibration sphere (tungsten carbide, aluminum, stainless steel, copper)
#' @param diameter The diameter of the sphere (mm).
#' @param fs Frequency start (Hz).
#' @param fe Frequency end (Hz).
#' @param fi Frequency interval (Hz).
#' @examples
#' frequency <- 120e3
#' c <- 1500
#' rho <- 1030
#' material <- "Tungsten carbide"
#' diameter <- 38.1
#'
#' sphere.spec(frequency,c,rho,material,diameter,fs=18e3,fe=230e3,fi=1e3)
#' @return Returns the TS-frequency spectrum of an elastic sphere.
#' @export
sphere.spec <- function(c,rho,material="Tungsten carbide",diameter,fs,fe,fi){
freq_spec <- seq(from=fs, to=fe, by=fi) #frequency spectrum
sphere_mat <- sphere_param(material) #call sphere material properties
a <- diameter*1e-3/2 #calculate radius; convert from diameter to radius; m
alpha <- 2*(as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c2"]])/c)^2 #Equation 6d
beta <- (as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c1"]])/c)^2 - alpha #Equation 6e
tmp.df <- data.frame(Frequency=freq_spec, TS=NA) #Generate dataframe
pb <- winProgressBar(title="Processing frequencies...", label="0% completed", min=0, max=100, initial=0)
for(i in 1:nrow(tmp.df)){
k <- 2*pi*tmp.df$Frequency[i]/c #acoustic wavenumber
q <- k*a #ka variable; Equation 6a
q1 <- q * c / as.numeric(sphere_mat[["c1"]]) #Equation 6a
q2 <- q * c / as.numeric(sphere_mat[["c2"]]) #Equation 6a
tmp.df$TS[i] <- round(TS_calculate(q,q1,q2,alpha,beta,a),2)
load.info <- sprintf("%d%% completed", round((i/nrow(tmp.df))*100))
setWinProgressBar(pb, i/(nrow(tmp.df))*100, label=load.info)
}
close(pb)
return(tmp.df)
}
#' Plots the TS-frequency spectrum.
#'
#' @description
#' This function generates a plot of the TS-frequency spectrum using ggplot2.
#'
#' @param df A dataframe generated from the sphere.spec(...) function with two columns: Frequency and TS.
#' @examples
#' ts.df <- sphere.spec(frequency=120e3,c=1500,rho=1030,material="Tungsten carbide",diameter=38.1,fs=18e3,fe=230e3,fi=1e3)
#' sphere.spec_plot(ts.df)
#'
#' @return
#' Generates TS-frequency spectrum for an elastic sphere.
#' @export
#' @import ggplot2
sphere.spec_plot <- function(df){
require(ggplot2)
p1 <- ggplot(data=df, aes(x=Frequency/1000,y=TS)) + geom_path(size=1) + geom_point(size=3) +
theme_bw() +
theme(text=element_text(size=18), axis.text=element_text(size=18, colour="black"),
panel.grid=element_blank()) +
labs(x="Frequency (kHz)",
y=expression(paste("Target strength (dB re: ",m^2," at 1m)")))
return(p1)
}
material="Tungsten carbide"
sphere_mat <- sphere_param(material) #call sphere material properties
sphere_mat
a <- diameter*1e-3/2 #calculate radius; convert from diameter to radius; m
a
diameter=38.1
a <- diameter*1e-3/2 #calculate radius; convert from diameter to radius; m
alpha <- 2*(as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c2"]])/c)^2 #Equation 6d
beta <- (as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c1"]])/c)^2 - alpha #Equation 6e
k <- 2*pi*frequency/c #acoustic wavenumber
q <- k*a #ka variable; Equation 6a
q1 <- q * c / as.numeric(sphere_mat[["c1"]]) #Equation 6a
q2 <- q * c / as.numeric(sphere_mat[["c2"]]) #Equation 6a
q
q1
q2
frequency
k*a
a
k
q
c
c=1500
2*pi*frequency/c
k <- 2*pi*frequency/c #acoustic wavenumber
q <- k*a #ka variable; Equation 6a
q1 <- q * c / as.numeric(sphere_mat[["c1"]]) #Equation 6a
q2 <- q * c / as.numeric(sphere_mat[["c2"]]) #Equation 6a
TS_calculate(q,q1,q2,alpha,beta,a)
frequency=125500
sphere_mat <- sphere_param(material) #call sphere material properties
a <- diameter*1e-3/2 #calculate radius; convert from diameter to radius; m
alpha <- 2*(as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c2"]])/c)^2 #Equation 6d
beta <- (as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c1"]])/c)^2 - alpha #Equation 6e
k <- 2*pi*frequency/c #acoustic wavenumber
q <- k*a #ka variable; Equation 6a
q1 <- q * c / as.numeric(sphere_mat[["c1"]]) #Equation 6a
q2 <- q * c / as.numeric(sphere_mat[["c2"]]) #Equation 6a
TS_calculate(q,q1,q2,alpha,beta,a)
q2
alpha
beta
q <- as.numeric(q)
k <- TRUE #While loop flag
l <- 0 #Iteration value
foo_ll <- 0
foo_l_prev <- 0 #Previous iteration of summed term in Equation 7
A2 <- (l^2 + l - 2)* jl(l,q2,1) + q2^2 * jdd(l,q2) #Equation 6b
A1 <- 2 * l * (l + 1) * (q1 * jd(l,q1) - jl(l,q1,1)) #Equation 6c
B2 <- A2 * q1^2 * (beta*jl(l,q1,1) - alpha*jdd(l,q1)) - A1 * alpha * (jl(l,q2,1) - q2 * jd(l,q2)) #Equation 6f
B1 <- q * (A2 * q1 * jd(l,q1) - A1 * jl(l,q2,1)) #Equation 6g
eta_l <- atan(-(B2 * jd(l,q) - B1 * jl(l,q,1)) / (B2 * yd(l,q) - B1*yl(l,q))) #Equation 6h
foo_l <- (-1)^l * (2*l+1) * sin(eta_l) * exp(1i*eta_l) #Equation 7; what is calculated and summed for "l"th iteration
foo_ll <- foo_ll + foo_l #Sum up to current iteration
if(abs(foo_l/foo_ll) < 1e-10){
k <- FALSE
}else{
l <- l + 1
}
foo_ll
A2
B2
A1
B1
eta_l
B2 * jd(l,q)
B2
jd(l,q)
l
q
jl(l,n,-1)
l=1
n=10.01445
jl(l,n,-1)
jl(l,n,-1)
jl(l,n,-1) - (l+1)
jl(l,n,-1) - (l+1) / n
jl(l,n,1)
jl(1,1,1)
jl(1,10.01445,1)
jl(1,1)
jl(1,1,0)
jl(1,1,1)
jl(1,1,-1)
jl(1,2,1)
jl(1,10,1)
jl(1,10.01445,1)
jl(1,-1,0)
jl(-1,-1,-1)
jl(-1,-1,1)
jl(-1,-1,0)
jl(1,1)
jl
jl(1,1,1)
jd(1,1)
jd(1,10.01445)
jl(1,10.01445,1)
ja(l+0.5, n)
ja(1,1)
ja(1.5,1)
l
n
ja(1.5,2)
ja(1.5,10)
ja(1.5,10.5)
#Bessel function of first or second kind calculation
ja <- function(l,n){
if(n == 0){
s <- 0
}else{
if(n > 0){
nn <- n
}else{
nn <- abs(n)
}
if(nn > 20){
s <- sqrt(2/(pi*nn)) * cos(nn - (l/2 + 0.25)*pi)
}else if(nn < 0.01){
s <- (0.5*nn)^l / gamma(l+1)
}else{
if(l >= 0){
ll <- l
}else if(l < 0 & l%%1==0){
ll <- abs(l)
}else{
ll <- l
}
f <- 0; t <- 0; s <- 0; i <- 0
while(f == 0){
s <- s + (-1)^i * (nn/2)^(ll+2*i) / (factorial(i) * gamma(i+ll+1))
if(abs(s - t) < 1e-30){f <- 1}
t <- s; i <- i + 1
}
if(n < 0){
if(l > 0){
s <- -1^l * s
}else if(l%%1!=0){
if(s < 0){
s <- 1i*s
}else{
s <- -1i*s
}
}
}else{
if(l < 0 & l%%1==0){
s <- -1^l * s
}
}
}
}
return(s)
}
ja(1.5,10.5)
ja(1.5,10.01445)
jl(1.5,10.01445)
js(1,10.01445)
ja(l+0.5, n) * sqrt(pi/2/n)
-1^l * (ja(abs(l)+0.5, abs(n)) * sqrt(pi/2/abs(n)))
js
#Spherical Bessel function of first kind
js <- function(l,n){
if(n == 0){
return(0)
}else if(n > 0){
return(ja(l+0.5, n) * sqrt(pi/2/n))
}else{
return(-1^l * (ja(abs(l)+0.5, abs(n)) * sqrt(pi/2/abs(n))))
}
}
ja(l+0.5, n) * sqrt(pi/2/n)
js(1,10.01445)
jsd(1,10.01445)
1 / (n^2) * ((l+1)*(l+2) - n^2) * jl(l,n,1) - 2 / n * jl(l,n,-1)
jl(l,n,-1) - (l+1) / n * jl(l,n,1)
jl(l,n,-1)
jl(l,n,-1) - (l+1)
TS_calculate(q,q1,q2,alpha,beta,a)
sphere_mat <- sphere_param(material) #call sphere material properties
a <- diameter*1e-3/2 #calculate radius; convert from diameter to radius; m
alpha <- 2*(as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c2"]])/c)^2 #Equation 6d
beta <- (as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c1"]])/c)^2 - alpha #Equation 6e
k <- 2*pi*frequency/c #acoustic wavenumber
q <- k*a #ka variable; Equation 6a
q1 <- q * c / as.numeric(sphere_mat[["c1"]]) #Equation 6a
q2 <- q * c / as.numeric(sphere_mat[["c2"]]) #Equation 6a
TS_calculate(q,q1,q2,alpha,beta,a)
a
frequency
frequency=120e3
sphere_mat <- sphere_param(material) #call sphere material properties
a <- diameter*1e-3/2 #calculate radius; convert from diameter to radius; m
alpha <- 2*(as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c2"]])/c)^2 #Equation 6d
beta <- (as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c1"]])/c)^2 - alpha #Equation 6e
k <- 2*pi*frequency/c #acoustic wavenumber
q <- k*a #ka variable; Equation 6a
q1 <- q * c / as.numeric(sphere_mat[["c1"]]) #Equation 6a
q2 <- q * c / as.numeric(sphere_mat[["c2"]]) #Equation 6a
S_calculate(q,q1,q2,alpha,beta,a)
TS_calculate(q,q1,q2,alpha,beta,a)
frequency=125500
sphere_mat <- sphere_param(material) #call sphere material properties
a <- diameter*1e-3/2 #calculate radius; convert from diameter to radius; m
alpha <- 2*(as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c2"]])/c)^2 #Equation 6d
beta <- (as.numeric(sphere_mat[["rho1"]])/rho)*(as.numeric(sphere_mat[["c1"]])/c)^2 - alpha #Equation 6e
k <- 2*pi*frequency/c #acoustic wavenumber
q <- k*a #ka variable; Equation 6a
q1 <- q * c / as.numeric(sphere_mat[["c1"]]) #Equation 6a
q2 <- q * c / as.numeric(sphere_mat[["c2"]]) #Equation 6a
q2
alpha
beta
q <- as.numeric(q)
k <- TRUE #While loop flag
l <- 0 #Iteration value
foo_ll <- 0
foo_l_prev <- 0 #Previous iteration of summed term in Equation 7
A2 <- (l^2 + l - 2)* jl(l,q2,1) + q2^2 * jdd(l,q2) #Equation 6b
A1 <- 2 * l * (l + 1) * (q1 * jd(l,q1) - jl(l,q1,1)) #Equation 6c
B2 <- A2 * q1^2 * (beta*jl(l,q1,1) - alpha*jdd(l,q1)) - A1 * alpha * (jl(l,q2,1) - q2 * jd(l,q2)) #Equation 6f
B1 <- q * (A2 * q1 * jd(l,q1) - A1 * jl(l,q2,1)) #Equation 6g
eta_l <- atan(-(B2 * jd(l,q) - B1 * jl(l,q,1)) / (B2 * yd(l,q) - B1*yl(l,q))) #Equation 6h
foo_l <- (-1)^l * (2*l+1) * sin(eta_l) * exp(1i*eta_l) #Equation 7; what is calculated and summed for "l"th iteration
foo_ll <- foo_ll + foo_l #Sum up to current iteration
foo_ll
A1
A2
(l^2 + l - 2)* jl(l,q2,1) + q2^2 * jdd(l,q2)
jdd(l,q2)
jdd
l
n
l
q2
jdd(l,q2)
l
l=0
n=q2
1 / (n^2)
1 / (n^2) * ((l+1)*(l+2) - n^2)
A2
(l^2 + l - 2)
(l^2 + l - 2)* jl(l,q2,1)
(l^2 + l - 2)* jl(l,q2,1) + q2^2
(l^2 + l - 2)* jl(l,q2,1) + q2^2 * jdd(l,q2)
A2 <- (l^2 + l - 2)* jl(l,q2,1) + q2^2 * jdd(l,q2) #Equation 6b
A1 <- 2 * l * (l + 1) * (q1 * jd(l,q1) - jl(l,q1,1)) #Equation 6c
A1
B2 <- A2 * q1^2 * (beta*jl(l,q1,1) - alpha*jdd(l,q1)) - A1 * alpha * (jl(l,q2,1) - q2 * jd(l,q2)) #Equation 6f
B1 <- q * (A2 * q1 * jd(l,q1) - A1 * jl(l,q2,1)) #Equation 6g
eta_l <- atan(-(B2 * jd(l,q) - B1 * jl(l,q,1)) / (B2 * yd(l,q) - B1*yl(l,q))) #Equation 6h
foo_l <- (-1)^l * (2*l+1) * sin(eta_l) * exp(1i*eta_l) #Equation 7; what is calculated and summed for "l"th iteration
foo_ll <- foo_ll + foo_l #Sum up to current iteration
foo_ll
q <- as.numeric(q)
k <- TRUE #While loop flag
l <- 0 #Iteration value
foo_ll <- 0
foo_l_prev <- 0 #Previous iteration of summed term in Equation 7
A2 <- (l^2 + l - 2)* jl(l,q2,1) + q2^2 * jdd(l,q2) #Equation 6b
A1 <- 2 * l * (l + 1) * (q1 * jd(l,q1) - jl(l,q1,1)) #Equation 6c
B2 <- A2 * q1^2 * (beta*jl(l,q1,1) - alpha*jdd(l,q1)) - A1 * alpha * (jl(l,q2,1) - q2 * jd(l,q2)) #Equation 6f
B1 <- q * (A2 * q1 * jd(l,q1) - A1 * jl(l,q2,1)) #Equation 6g
eta_l <- atan(-(B2 * jd(l,q) - B1 * jl(l,q,1)) / (B2 * yd(l,q) - B1*yl(l,q))) #Equation 6h
foo_l <- (-1)^l * (2*l+1) * sin(eta_l) * exp(1i*eta_l) #Equation 7; what is calculated and summed for "l"th iteration
foo_ll <- foo_ll + foo_l #Sum up to current iteration
foo_ll
A1
B2
B1
eta_l
-(B2 * jd(l,q) - B1 * jl(l,q,1))
(B2 * yd(l,q) - B1*yl(l,q))
yd(l,q)
l
q
yd(1,1)
yd(1,10)
yd(1,10.2)
ya(l+0.5,n)
sqrt(pi/2/n)
ya(l+0.5,n) * sqrt(pi/2/n)
n
l
l=1
n=10.2
ya(l+0.5,n) * sqrt(pi/2/n)
ya(l+0.5,n)
ya(1,10.2)
ya(1,1)
ya
ya(1,2)
ya(2,2)
#Bessel function of first or second kind calculation
ya <- function(l,n){return((ja(l,n) * cos(l*pi) - ja(-l,n)) / sin(l*pi))}
ya(1,1)
ja(1,1)
ya(1,10)
ya(1,10.2)
ja(l,n)
(ja(l,n) * cos(l*pi)
-ja(-l,n)
(ja(l,n) * cos(l*pi) - ja(-l,n))
ya(1,1)
yl(1,1)
ya
ya <- function(l,n){return((ja(l,n) * cos(l*pi) - ja(-l,n)) / sin(l*pi))}
ya(1,1)
yl(1,1)
yl(1,10.2)
ya(1,1)
#Bessel function of first or second kind calculation
ya <- function(l,n){
nn <- abs(n)
ll <- abs(l)
if(ll%%1==0){
p1 <- -(nn/2)^(-ll)/pi
p2 <- 0
for (i in seq(0, (ll - 1), 1)) {
p2 <- p2 + (factorial(ll - i - 1)/factorial(i)) *
(nn^2/4)^i
}
p3 <- 2/pi * log(nn/2) * ja(ll, nn)
f <- 0; t <- 0; i <- 0
p4 <- 0
while (f == 0) {
p4 <- p4 + (digamma(i + 1) + digamma(ll + i + 1)) *
((-nn^2/4)^i)/(factorial(i) * factorial(ll + i))
if (abs(p4 - t) < 1e-30) {
f <- 1
}
t <- p4
i <- i + 1
}
s <- p1 * p2 + p3 - (nn/2)^ll/pi * p4
}else{
s <- (ja(ll, nn) * cos(ll * pi) - ja(-ll, nn))/sin(ll * pi)
}
if(n < 0){
if(n%%1 == 0){
if(l%%1==0){
s <- -1^ll * s + 1i*(-1)^ll*2*ja(ll,nn)
}else{
s <- 1i*-1^(ll+1) * s
}
}
}
if(l < 0){
if(l%%1==0){
s <- -1^l * s
}else{
s <- -1^l * ja(ll+0.5, n)
}
}
return(s)
}
ya(1,1)
ya(1,10.2)
ys(1,10.2)
ys
#' l <- 1
#' n <- 1
#' ys(l,n)
#' # -1.381773
#' @return
#' ys(l,n) calculates the spherical Bessel function of the second kind (zbesy
#' AMOS routine, Yv)
#' @rdname ys
#' @export
#Spherical Bessel function of second kind
ys <- function(l,n){
if(n > 0){
return(ya(l+0.5,n) * sqrt(pi/2/n))
}else if(n < 0){
return(-(ya(l+0.5,n) * sqrt(pi/2/n)))
}else if(n == 0){
return(Inf)
}
}
ys(1,10.2)
ysd(1,10.2)
yd(1,10.2)
l / n * yl(l,n)
l / n * yl(l,n) - yl(l+1,n)
