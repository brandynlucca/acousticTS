}
g = SDWBA.sim(epac, frequency=120e3, c=1500, nrep=1e3, parallel=T)
SDWBA.sim <- function(shape=shape, x=shape@rpos[1,], y=shape@rpos[2,], z=shape@rpos[3,],
c=1500, frequency, phase=0.0, a=shape@a, h=shape@h, g=shape@g,
curve=shape@curve,
pc=shape@pc,
theta=shape@theta,
length=shape@L,
scale="log",
nrep=NULL, permute=F, aggregate=NULL, parallel=F, n.cores=NULL,
progress=T){
if(theta[1] != shape@theta){
theta <- theta + pi/2
}
if(!is.null(nrep)){
repseq <- seq(1,nrep,1)
}else{
repseq <- 1
}
if(permute == T){
simdf <- expand.grid(iteration=repseq, c=c, frequency=frequency, g=g, h=h, theta=theta, pc=pc, curve=curve, phase=phase, length=length, TS=NA)
}else{
lendf <- data.frame(param=c("h","g","curve","pc","theta","length","phase"),
len=c(length(h),length(g),length(curve),length(pc),length(theta),length(length),length(phase)))
val<- data.frame(x=seq(1,max(lendf$len),1))
simdf <- expand.grid(iteration=repseq, iterator=t(val), c=c, frequency=frequency)
simdf <- cbind(simdf, data.frame(g=rep(g,max(lendf$len)/lendf$len[2]*max(repseq)),
h=rep(h,max(lendf$len)/lendf$len[1]*max(repseq)),
theta=rep(theta,lendf$len[5]/max(lendf$len)*max(repseq)),
pc=rep(pc,max(lendf$len)/lendf$len[4]*max(repseq)),
curve=rep(curve,max(lendf$len)/lendf$len[3]*max(repseq)),
phase=rep(phase,max(lendf$len)/lendf$len[7]*max(repseq)),
length=rep(length,max(lendf$len)/lendf$len[6]*max(repseq)),
TS=NA))
simdf <- simdf[,-2]
}
if(progress == T){
bar <- txtProgressBar(min=1, max=nrow(simdf), style=3, title="Calculating TS values...")
progbar <- function(n) setTxtProgressBar(bar, n)
}
if(parallel==F){
for(i in 1:nrow(simdf)){
target_sim <- Shapely(shape,curve=simdf$curve[i],pc=simdf$pc[i],theta=simdf$theta[i],length=simdf$length[i])
simdf$TS[i] <- SDWBA(target_sim,c=simdf$c[i],frequency=simdf$frequency[i],phase=simdf$phase[i],g=simdf$g[i],h=simdf$h[i])
if(progress == T){
progbar(i)
}
}
}else if(parallel==T){
requireNamespace("foreach", quietly=T)
requireNamespace("doParallel", quietly=T)
if(!is.null(n.cores)){
n.cores <- n.cores
}else{
n.cores <- detectCores()
}
cl <- makeSOCKcluster(n.cores)
registerDoSNOW(cl)
if(progress == T){
bar <- txtProgressBar(min=1, max=nrow(simdf), style=3)
opts <- list(progress=progbar)
}else{
opts <- list()
}
simdf$TS <- foreach(i=1:nrow(simdf), .combine=c, .packages="acousticTS", .options.snow=opts) %dopar% {
target_sim <- Shapely(shape,curve=simdf$curve[i],pc=simdf$pc[i],theta=simdf$theta[i],length=simdf$length[i])
SDWBA(target_sim,c=simdf$c[i],frequency=simdf$frequency[i],phase=simdf$phase[i],g=simdf$g[i],h=simdf$h[i])
}
stopCluster(cl)
if(progress == T){
close(bar)
}
}
close(bar)
if(!is.null(aggregate)){
dum <- data.frame(Stat=NA,TS=NA)
if("mean" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Mean", TS=10*log10(mean(10^(simdf$TS/10)))))
}
if("median" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Median", TS=median(simdf$TS)))
}
if("minimum" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Minimum", TS=min(simdf$TS)))
}
if("maximum" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Maximum", TS=max(simdf$TS)))
}
dum <- dum[-(is.na(dum$Stat)),]
return(dum)
}else{
if(scale %in% c("linear","both")){
simdf$sigmabs <- 10^(simdf$TS/10)
if(scale == "linear"){
simdf <- simdf[-(which(colnames(simdf) == "TS"))]
}
}
return(simdf)
}
}
g = SDWBA.sim(epac, frequency=120e3, c=1500, nrep=1e3, parallel=T)
g = SDWBA.sim(epac, frequency=120e3, c=1500, nrep=1e2, parallel=F, progress=F)
g = SDWBA.sim(epac, frequency=120e3, c=1500, nrep=1e2, parallel=F, progress=T)
SDWBA.sim <- function(shape=shape, x=shape@rpos[1,], y=shape@rpos[2,], z=shape@rpos[3,],
c=1500, frequency, phase=0.0, a=shape@a, h=shape@h, g=shape@g,
curve=shape@curve,
pc=shape@pc,
theta=shape@theta,
length=shape@L,
scale="log",
nrep=NULL, permute=F, aggregate=NULL, parallel=F, n.cores=NULL,
progress=T){
if(theta[1] != shape@theta){
theta <- theta + pi/2
}
if(!is.null(nrep)){
repseq <- seq(1,nrep,1)
}else{
repseq <- 1
}
if(permute == T){
simdf <- expand.grid(iteration=repseq, c=c, frequency=frequency, g=g, h=h, theta=theta, pc=pc, curve=curve, phase=phase, length=length, TS=NA)
}else{
lendf <- data.frame(param=c("h","g","curve","pc","theta","length","phase"),
len=c(length(h),length(g),length(curve),length(pc),length(theta),length(length),length(phase)))
val<- data.frame(x=seq(1,max(lendf$len),1))
simdf <- expand.grid(iteration=repseq, iterator=t(val), c=c, frequency=frequency)
simdf <- cbind(simdf, data.frame(g=rep(g,max(lendf$len)/lendf$len[2]*max(repseq)),
h=rep(h,max(lendf$len)/lendf$len[1]*max(repseq)),
theta=rep(theta,lendf$len[5]/max(lendf$len)*max(repseq)),
pc=rep(pc,max(lendf$len)/lendf$len[4]*max(repseq)),
curve=rep(curve,max(lendf$len)/lendf$len[3]*max(repseq)),
phase=rep(phase,max(lendf$len)/lendf$len[7]*max(repseq)),
length=rep(length,max(lendf$len)/lendf$len[6]*max(repseq)),
TS=NA))
simdf <- simdf[,-2]
}
if(progress == T){
bar <- txtProgressBar(min=1, max=nrow(simdf), style=3, title="Calculating TS values...")
progbar <- function(n) setTxtProgressBar(bar, n)
}
if(parallel==F){
for(i in 1:nrow(simdf)){
target_sim <- Shapely(shape,curve=simdf$curve[i],pc=simdf$pc[i],theta=simdf$theta[i],length=simdf$length[i])
simdf$TS[i] <- SDWBA(target_sim,c=simdf$c[i],frequency=simdf$frequency[i],phase=simdf$phase[i],g=simdf$g[i],h=simdf$h[i])
if(progress == T){
progbar(i)
}
}
}else if(parallel==T){
requireNamespace("foreach", quietly=T)
requireNamespace("doParallel", quietly=T)
if(!is.null(n.cores)){
n.cores <- n.cores
}else{
n.cores <- detectCores()
}
cl <- makeSOCKcluster(n.cores)
registerDoSNOW(cl)
if(progress == T){
bar <- txtProgressBar(min=1, max=nrow(simdf), style=3)
opts <- list(progress=progbar)
}else{
opts <- list()
}
simdf$TS <- foreach(i=1:nrow(simdf), .combine=c, .packages="acousticTS", .options.snow=opts) %dopar% {
target_sim <- Shapely(shape,curve=simdf$curve[i],pc=simdf$pc[i],theta=simdf$theta[i],length=simdf$length[i])
SDWBA(target_sim,c=simdf$c[i],frequency=simdf$frequency[i],phase=simdf$phase[i],g=simdf$g[i],h=simdf$h[i])
}
stopCluster(cl)
if(progress == T){
close(bar)
}
}
if(!is.null(aggregate)){
dum <- data.frame(Stat=NA,TS=NA)
if("mean" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Mean", TS=10*log10(mean(10^(simdf$TS/10)))))
}
if("median" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Median", TS=median(simdf$TS)))
}
if("minimum" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Minimum", TS=min(simdf$TS)))
}
if("maximum" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Maximum", TS=max(simdf$TS)))
}
dum <- dum[-(is.na(dum$Stat)),]
return(dum)
}else{
if(scale %in% c("linear","both")){
simdf$sigmabs <- 10^(simdf$TS/10)
if(scale == "linear"){
simdf <- simdf[-(which(colnames(simdf) == "TS"))]
}
}
return(simdf)
}
}
g = SDWBA.sim(epac, frequency=120e3, c=1500, nrep=1e2, parallel=F, progress=T)
g = SDWBA.sim(epac, frequency=120e3, c=1500, nrep=1e2, parallel=F, progress=F)
?detectCores()
?doSNOW
?makeSOCKcluster
?registerDoSNOW
SDWBA.sim <- function(shape=shape, x=shape@rpos[1,], y=shape@rpos[2,], z=shape@rpos[3,],
c=1500, frequency, phase=0.0, a=shape@a, h=shape@h, g=shape@g,
curve=shape@curve,
pc=shape@pc,
theta=shape@theta,
length=shape@L,
scale="log",
nrep=NULL, permute=F, aggregate=NULL, parallel=F, n.cores=NULL,
progress=T){
if(theta[1] != shape@theta){
theta <- theta + pi/2
}
if(!is.null(nrep)){
repseq <- seq(1,nrep,1)
}else{
repseq <- 1
}
if(permute == T){
simdf <- expand.grid(iteration=repseq, c=c, frequency=frequency, g=g, h=h, theta=theta, pc=pc, curve=curve, phase=phase, length=length, TS=NA)
}else{
lendf <- data.frame(param=c("h","g","curve","pc","theta","length","phase"),
len=c(length(h),length(g),length(curve),length(pc),length(theta),length(length),length(phase)))
val<- data.frame(x=seq(1,max(lendf$len),1))
simdf <- expand.grid(iteration=repseq, iterator=t(val), c=c, frequency=frequency)
simdf <- cbind(simdf, data.frame(g=rep(g,max(lendf$len)/lendf$len[2]*max(repseq)),
h=rep(h,max(lendf$len)/lendf$len[1]*max(repseq)),
theta=rep(theta,lendf$len[5]/max(lendf$len)*max(repseq)),
pc=rep(pc,max(lendf$len)/lendf$len[4]*max(repseq)),
curve=rep(curve,max(lendf$len)/lendf$len[3]*max(repseq)),
phase=rep(phase,max(lendf$len)/lendf$len[7]*max(repseq)),
length=rep(length,max(lendf$len)/lendf$len[6]*max(repseq)),
TS=NA))
simdf <- simdf[,-2]
}
if(progress == T){
bar <- txtProgressBar(min=1, max=nrow(simdf), style=3, title="Calculating TS values...")
progbar <- function(n) setTxtProgressBar(bar, n)
}
if(parallel==F){
for(i in 1:nrow(simdf)){
target_sim <- Shapely(shape,curve=simdf$curve[i],pc=simdf$pc[i],theta=simdf$theta[i],length=simdf$length[i])
simdf$TS[i] <- SDWBA(target_sim,c=simdf$c[i],frequency=simdf$frequency[i],phase=simdf$phase[i],g=simdf$g[i],h=simdf$h[i])
if(progress == T){
progbar(i)
}
}
}else if(parallel==T){
requireNamespace("foreach", quietly=T)
requireNamespace("doSNOW", quietly=T)
if(!is.null(n.cores)){
n.cores <- n.cores
}else{
n.cores <- detectCores()
}
cl <- makeSOCKcluster(n.cores)
registerDoSNOW(cl)
if(progress == T){
bar <- txtProgressBar(min=1, max=nrow(simdf), style=3)
opts <- list(progress=progbar)
}else{
opts <- list()
}
simdf$TS <- foreach(i=1:nrow(simdf), .combine=c, .packages="acousticTS", .options.snow=opts) %dopar% {
target_sim <- Shapely(shape,curve=simdf$curve[i],pc=simdf$pc[i],theta=simdf$theta[i],length=simdf$length[i])
SDWBA(target_sim,c=simdf$c[i],frequency=simdf$frequency[i],phase=simdf$phase[i],g=simdf$g[i],h=simdf$h[i])
}
stopCluster(cl)
if(progress == T){
close(bar)
}
}
if(!is.null(aggregate)){
dum <- data.frame(Stat=NA,TS=NA)
if("mean" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Mean", TS=10*log10(mean(10^(simdf$TS/10)))))
}
if("median" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Median", TS=median(simdf$TS)))
}
if("minimum" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Minimum", TS=min(simdf$TS)))
}
if("maximum" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Maximum", TS=max(simdf$TS)))
}
dum <- dum[-(is.na(dum$Stat)),]
return(dum)
}else{
if(scale %in% c("linear","both")){
simdf$sigmabs <- 10^(simdf$TS/10)
if(scale == "linear"){
simdf <- simdf[-(which(colnames(simdf) == "TS"))]
}
}
return(simdf)
}
}
rm(list=ls())
require(acousticTS)
SDWBA.sim <- function(shape=shape, x=shape@rpos[1,], y=shape@rpos[2,], z=shape@rpos[3,],
c=1500, frequency, phase=0.0, a=shape@a, h=shape@h, g=shape@g,
curve=shape@curve,
pc=shape@pc,
theta=shape@theta,
length=shape@L,
scale="log",
nrep=NULL, permute=F, aggregate=NULL, parallel=F, n.cores=NULL,
progress=T){
if(theta[1] != shape@theta){
theta <- theta + pi/2
}
if(!is.null(nrep)){
repseq <- seq(1,nrep,1)
}else{
repseq <- 1
}
if(permute == T){
simdf <- expand.grid(iteration=repseq, c=c, frequency=frequency, g=g, h=h, theta=theta, pc=pc, curve=curve, phase=phase, length=length, TS=NA)
}else{
lendf <- data.frame(param=c("h","g","curve","pc","theta","length","phase"),
len=c(length(h),length(g),length(curve),length(pc),length(theta),length(length),length(phase)))
val<- data.frame(x=seq(1,max(lendf$len),1))
simdf <- expand.grid(iteration=repseq, iterator=t(val), c=c, frequency=frequency)
simdf <- cbind(simdf, data.frame(g=rep(g,max(lendf$len)/lendf$len[2]*max(repseq)),
h=rep(h,max(lendf$len)/lendf$len[1]*max(repseq)),
theta=rep(theta,lendf$len[5]/max(lendf$len)*max(repseq)),
pc=rep(pc,max(lendf$len)/lendf$len[4]*max(repseq)),
curve=rep(curve,max(lendf$len)/lendf$len[3]*max(repseq)),
phase=rep(phase,max(lendf$len)/lendf$len[7]*max(repseq)),
length=rep(length,max(lendf$len)/lendf$len[6]*max(repseq)),
TS=NA))
simdf <- simdf[,-2]
}
if(progress == T){
bar <- txtProgressBar(min=1, max=nrow(simdf), style=3, title="Calculating TS values...")
progbar <- function(n) setTxtProgressBar(bar, n)
}
if(parallel==F){
for(i in 1:nrow(simdf)){
target_sim <- Shapely(shape,curve=simdf$curve[i],pc=simdf$pc[i],theta=simdf$theta[i],length=simdf$length[i])
simdf$TS[i] <- SDWBA(target_sim,c=simdf$c[i],frequency=simdf$frequency[i],phase=simdf$phase[i],g=simdf$g[i],h=simdf$h[i])
if(progress == T){
progbar(i)
}
}
}else if(parallel==T){
requireNamespace("foreach", quietly=T)
requireNamespace("doSNOW", quietly=T)
if(!is.null(n.cores)){
n.cores <- n.cores
}else{
n.cores <- detectCores()
}
cl <- makeSOCKcluster(n.cores)
registerDoSNOW(cl)
if(progress == T){
bar <- txtProgressBar(min=1, max=nrow(simdf), style=3)
opts <- list(progress=progbar)
}else{
opts <- list()
}
simdf$TS <- foreach(i=1:nrow(simdf), .combine=c, .packages="acousticTS", .options.snow=opts) %dopar% {
target_sim <- Shapely(shape,curve=simdf$curve[i],pc=simdf$pc[i],theta=simdf$theta[i],length=simdf$length[i])
SDWBA(target_sim,c=simdf$c[i],frequency=simdf$frequency[i],phase=simdf$phase[i],g=simdf$g[i],h=simdf$h[i])
}
stopCluster(cl)
if(progress == T){
close(bar)
}
}
if(!is.null(aggregate)){
dum <- data.frame(Stat=NA,TS=NA)
if("mean" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Mean", TS=10*log10(mean(10^(simdf$TS/10)))))
}
if("median" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Median", TS=median(simdf$TS)))
}
if("minimum" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Minimum", TS=min(simdf$TS)))
}
if("maximum" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Maximum", TS=max(simdf$TS)))
}
dum <- dum[-(is.na(dum$Stat)),]
return(dum)
}else{
if(scale %in% c("linear","both")){
simdf$sigmabs <- 10^(simdf$TS/10)
if(scale == "linear"){
simdf <- simdf[-(which(colnames(simdf) == "TS"))]
}
}
return(simdf)
}
}
g = SDWBA.sim(epac, frequency=120e3, c=1500, nrep=1e2, parallel=F, progress=T)
require(acousticTS)
library("acousticTS", lib.loc="~/R/win-library/4.0")
library("acepack", lib.loc="~/R/win-library/4.0")
detach("package:acousticTS", unload=TRUE)
detach("package:acepack", unload=TRUE)
g = SDWBA.sim(epac, frequency=120e3, c=1500, nrep=1e2, parallel=F, progress=T)
data(epac)
require(acousticTS)
SDWBA.sim <- function(shape=shape, x=shape@rpos[1,], y=shape@rpos[2,], z=shape@rpos[3,],
c=1500, frequency, phase=0.0, a=shape@a, h=shape@h, g=shape@g,
curve=shape@curve,
pc=shape@pc,
theta=shape@theta,
length=shape@L,
scale="log",
nrep=NULL, permute=F, aggregate=NULL, parallel=F, n.cores=NULL,
progress=T){
if(theta[1] != shape@theta){
theta <- theta + pi/2
}
if(!is.null(nrep)){
repseq <- seq(1,nrep,1)
}else{
repseq <- 1
}
if(permute == T){
simdf <- expand.grid(iteration=repseq, c=c, frequency=frequency, g=g, h=h, theta=theta, pc=pc, curve=curve, phase=phase, length=length, TS=NA)
}else{
lendf <- data.frame(param=c("h","g","curve","pc","theta","length","phase"),
len=c(length(h),length(g),length(curve),length(pc),length(theta),length(length),length(phase)))
val<- data.frame(x=seq(1,max(lendf$len),1))
simdf <- expand.grid(iteration=repseq, iterator=t(val), c=c, frequency=frequency)
simdf <- cbind(simdf, data.frame(g=rep(g,max(lendf$len)/lendf$len[2]*max(repseq)),
h=rep(h,max(lendf$len)/lendf$len[1]*max(repseq)),
theta=rep(theta,lendf$len[5]/max(lendf$len)*max(repseq)),
pc=rep(pc,max(lendf$len)/lendf$len[4]*max(repseq)),
curve=rep(curve,max(lendf$len)/lendf$len[3]*max(repseq)),
phase=rep(phase,max(lendf$len)/lendf$len[7]*max(repseq)),
length=rep(length,max(lendf$len)/lendf$len[6]*max(repseq)),
TS=NA))
simdf <- simdf[,-2]
}
if(progress == T){
bar <- txtProgressBar(min=1, max=nrow(simdf), style=3, title="Calculating TS values...")
progbar <- function(n) setTxtProgressBar(bar, n)
}
if(parallel==F){
for(i in 1:nrow(simdf)){
target_sim <- Shapely(shape,curve=simdf$curve[i],pc=simdf$pc[i],theta=simdf$theta[i],length=simdf$length[i])
simdf$TS[i] <- SDWBA(target_sim,c=simdf$c[i],frequency=simdf$frequency[i],phase=simdf$phase[i],g=simdf$g[i],h=simdf$h[i])
if(progress == T){
progbar(i)
}
}
}else if(parallel==T){
requireNamespace("foreach", quietly=T)
requireNamespace("doSNOW", quietly=T)
if(!is.null(n.cores)){
n.cores <- n.cores
}else{
n.cores <- detectCores()
}
cl <- makeSOCKcluster(n.cores)
registerDoSNOW(cl)
if(progress == T){
bar <- txtProgressBar(min=1, max=nrow(simdf), style=3)
opts <- list(progress=progbar)
}else{
opts <- list()
}
simdf$TS <- foreach(i=1:nrow(simdf), .combine=c, .packages="acousticTS", .options.snow=opts) %dopar% {
target_sim <- Shapely(shape,curve=simdf$curve[i],pc=simdf$pc[i],theta=simdf$theta[i],length=simdf$length[i])
SDWBA(target_sim,c=simdf$c[i],frequency=simdf$frequency[i],phase=simdf$phase[i],g=simdf$g[i],h=simdf$h[i])
}
stopCluster(cl)
if(progress == T){
close(bar)
}
}
if(!is.null(aggregate)){
dum <- data.frame(Stat=NA,TS=NA)
if("mean" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Mean", TS=10*log10(mean(10^(simdf$TS/10)))))
}
if("median" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Median", TS=median(simdf$TS)))
}
if("minimum" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Minimum", TS=min(simdf$TS)))
}
if("maximum" %in% aggregate){
dum <- rbind(dum,data.frame(Stat="Maximum", TS=max(simdf$TS)))
}
dum <- dum[-(is.na(dum$Stat)),]
return(dum)
}else{
if(scale %in% c("linear","both")){
simdf$sigmabs <- 10^(simdf$TS/10)
if(scale == "linear"){
simdf <- simdf[-(which(colnames(simdf) == "TS"))]
}
}
return(simdf)
}
}
g = SDWBA.sim(epac, frequency=120e3, c=1500, nrep=1e2, parallel=F, progress=T)
roxygen2::roxygenise()
setwd("C:/Users/Brandyn/Documents/GitHub/acousticTS/")
roxygen2::roxygenise()
